Вирутальные машины. Лекция 5

<!-- Байка Иготти про какую-то другую виртуальную машину. Чуваки из сана основали стартапчик, который выжил и живет уже много лет. Хотели исполнять джаву более качественно(джава-ускоритель с большим хипом и малыми паузами GC). Сначала было прибыльно, потому что мало кто занимался, а сейчас - не очень. Прикольная особенность системы управления памятью заключалась в том, чтобы создать полностью параллельный и конкурентный сборщик, который еще и перемещал объекты(azul jvm или как-то так). Чуваки перемещали указатели без остановки мира каким-то хитрым трюком с page fault -->

* Управление памятью без коллекторов  
    * Многие люди в индустрии осознали тот факт, что если вы предоставляете людям однородные объекты и однородные ссылки, то люди пишут более неэффективный код. И надо бы вводить лайфтайм объектов на уровне типов, вводить механизмы передачи владения на уровне языка(как в С++).  
    * Есть еще всякие линейные системы типов, которые тоже пытаются управлять памятью на уровне типов.


* Динамическая трансляция  
    * Речь про то, как исполнять байткод быстро. Какие требования к JIT можем мы выдвинуть?
      * Начнем с того, что стандарт ничего не говорит про JIT, то есть он как бы и не нужен
      * Основное назначение - повышение производительности
      * Должен быть управляем(в джаве например нет конструкции inline). Со стороны байткода управляемость JIT минимальна
      * Что значит оптиизировать байткод? Вообще функция джита - генерировать машинный код, которому можно отдать управление
      * Что транслировать - блоки, методы, классы, пакеты

    Типичная реклама джита - возможность сделать оптимизации, недоступные в статике. Еще тема - предсказание ветвления(likely branches перемещаются ближе к предыдущему коду, чтобы процессор выбирал инструкции в кеш). Еще реклама - устранение виртуальных вызовов(вызвать вирутальный метод - дорогая операция), это хорошо с точки зрения конвейеров на процессоре(так называемая деполиморфизация). Джит в таком случае тупо подставит тип. Еще преимущества джита - он не оптимизирует код, который редко исполняется. Весьма сомнительная, потому что джит тупо ведет частотный анализ, а в один момент нечасто исполянемый код может стать часто исполняемым. Из этих соображений, в джите есть понятие деоптимизации

    В JVM транслятор пытается оптимизировать так называемые "common paths"

    Как работает деоптимизатор? Если хочется реоптимизировать метод, то надо просто поменять ему точку входа и все. В реальных системах приходится менять код не на входе метода, а внутри него(есть технология OSR - замены реализацией машинного кода с неметодной гранулярностью).

    [stackoverflow about OSR](http://stackoverflow.com/questions/9105505/differences-between-just-in-time-compilation-and-on-stack-replacement)

* Как вообще можно писать JIT
    * Абстрактная интерпретация - это интерпретатор, который понимает операционную семантику и интерпретирует согласно ней. Например, если мы видим инструкцию сложения, то мы __порождаем__ код, который снимает два значения со стека, складывает их и кладет на стек.
    * Тогда для простого джита нам надо уметь порождать машинный код для каждой небольшой инструкции. Тогда вся трансляция - это просто генерация соответствующего машинного кода.
    * IR - intermediate representation - то как транслятор представляет программу с которой он работает(пример - AST). По нему обычно строится некоторое производное промежуточное представление и по нему делается оптимизация(SSA - Single Static Assignment). Джит умеет делать над IR все то же самое, что и обычный АОТ-компилятор(инверсии циклов, вычисление констант времени компиляции, удаление мертвого кода, инлайнинг, выпиливание synchronized etc). АОТ не умеет порождать код, оптимизированный под __типичное исполнение__.

* Кто должен знать про JIT и с кем ему надо будет взаимодействовать
    * Система управления памятью? Наверное да, если транслятор что-то знает про лайфтайм объектов
    * Интерпретатор байткода?
    * Система управления блокировками? Наверное, да
    * С отладчиком? Определенно, да
    * Система обработки сигналов? Да, чтобы можно было нульпоинтеры не проверять

* На самом деле в хотспоте два транслятора! Один для клиентского кода(С1), второй - для серверного(С2). В проекты было две группы людей, которые ругались по поводу дизайна и ничего не осталось, как написать два транслятора. Что общего?
    * Оба JIT
    * Оба работают в трех фазах(байткод - IR - машинный код)
    * Серьезно используют интерпретатор
* А что разного?
    * С1 учитывает лишь количество вызовов метода, цикла и так далее
    * AST - это граф потока управления, в узлах которого SSA
    * Простой инлайнер с простейшими эвристиками(если инструкций меньше, чем некоторый порог, то инлайнит)
    * Простой регистровый аллокатор
    * В целом, отличается более простым дизайном, нежели С2
