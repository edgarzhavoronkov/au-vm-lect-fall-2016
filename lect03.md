Виртуальные машины. Лекция 3


Оффтопик. Описание домашки:
  * Дан парсер некоторого языка, по АСД напечатать исходный текст программы(pretty-print). Срок - до 10 октября, утро
  * Далее по мотивам этого языка будем писать виртуальную машину с различными фичами

Собственно, лекция. Вспомним, что нужно сделать, чтобы понять, чтобы объект не нужен.
Объект не нужен, когда программа его не использует(это якобы __определение__). А анализ достижимости - это скорее __способ__ понять, что объект не нужен. В языке С, например, анализ достижимости очень прост - область видимости закрылась -> объект не нужен

<!-- Что-то про корневой набор, класслоадеры и статические поля, я не записал =( -->
Корневой набор содержит класслоадеры, а те держат ссылки на свои классы. То есть есть системный класслоадер, который зашит и всегда жив. С точки зрения реализации, каждый объект знает свой размер и положение в хипе. Тогда можно обойти хипу и понять что-то про __все__ объекты, чтобы если увидеть ненужный объект вызвать для него финализатор

Разного рода ссылки. В джаве внезапно есть 4 вида ссылок(смотри спеку)!
  * Strong reference(String s = new String())
  * Soft reference(Если мало памяти, и есть хинт, что объект лучше удерживать, то он удерживается)
  * Weak reference(Например кэши, можно удалить, когда памяти мало. Если памяти мало и объект не нужен, то память освобождается)
  * Phantom reference(Используется в реализации очередей финализации)

Ужас в том, что финализаторы сами написаны на джаве. Возникает вопрос, в каком порядке они удаляются и так далее(могут из состояния недостижимого переходить в состояние достижимого). На дизайн GC влияет еще и наличие метода .hashCode(), не очень очевидно, почему это так.

Почти все дизайны в программировании возникают на основе каких-либо требований. Некоторые рекомендации к дизайну GC:
  1. Ожидаемые объемы данных
  2. Ожидаемые требования к производительности(производительность в случае сборщика мусора - это та скорость, с которой программа создает объекты)
  3. Время жизни(некоторые программы работают весьма недолго, поэтому их мусор можно собирать вместе с завершением программы)
  4. Гарантия на время отклика(В HFT пауза GC может стоить некоторых денег)
  5. Ожидаемая нагрузка на систему

Эвристическая информация, которую обычно строят про GC:
  * Гипотеза поколений. "Большинство объектов умирают молодыми". Удобно классифицировать объекты по поколениям
  * Данные обычно локальны по отношению к потоку и по отношению друг к другу. То есть если объект создает какие-то данные, то сам же их и использует. То есть относящиеся друг к другу объекты и данные можно хранить рядом(удобно с точки зрения кэша процессора)
  * Еще одно наблюдение, что в джаве на любом объекте можно синхронизироваться, ждать и уведомлять. На самом деле, синхронизируются на немногих объектах
  * То же наблюдение для хешей. Все можно положить в хеш-таблицу, но по факту кладут не все классы объектов

Один из GC для JVM - подсчет ссылок, вполне себе корректный GC:
  * В некотором смысле - просто написать
  * Не очень ясно про то, где точно лежат ссылки. Точно ли мы знаем, или нет, где лежат объекты
  * А как понять, если мы сейчас смотрим на ссылку(посмотреть, лежит ли в диапазоне адресов хипа)

Есть сборщики, копирующие объекты(повышающие локальность объектов).
Есть сборщики останавливающие мир(выполнение программы). Они делают вычисления на графе объектов и пытаются понять, что изменится в графе объектов. Есть сборщики мусора реального времени(особо не используются)

<!-- Байка про CPS-фреймворк на исключениях -->

В джавовском хотспоте 5 коллекторов:
  * Последовательный(Mark and sweep)
  * Параллельный(классический коллектор в несколько потоков, который останавливает мир)
  * Конкурентный(работает более или менее параллельно исполнению программы и инкрементально собирает объекты, останавливает мир, но на очень короткое время)
  * Сборщик с гарантиями реального времени
  * Garbage first(разбивает хипу на регионы предсказуемого размера и собирает регионы про которые верит, что там больше всего мусора, некоторое продолжение гипотезы поколений)

На время работы одной машины джавы запускается один сборщик мусора. Все сборщики мусора точные(все всегда знают, где у объектов ссылки). Все обладают явно выраженными поколениями(обычно тремя):
  * Young gen(для новых объектов, в котором чаще всего происходит сборка)
  * Old gen(для больших объектов и объектов, которые не собираются умирать молодыми)
  * Perm gen(для структур JVM)
