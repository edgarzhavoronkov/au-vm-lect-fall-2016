Виртуальные машины. Лекция 11(или 10)

Valgrind

- Еще один пример виртуальной машины, которая программно эмулирет код чтобы отыскивать утечки памяти и так далее. Транслирует код в RISC-подобное промежуточное представление, которое потом инструментируется. Есть возможность создать на базе него практически любой бинарный анализатор. Более популярные инструменты для анализа кода - всякие гугловые санитайзеры(потому что менее интрузивны)

Virtual Box

- Пример гипервизора. Как устроен, как разрабатывался и так далее.

- Немного истории. Чуваки из майкрософта решили аутсорсить паравиртуализированные драйвера для мыши и видеокарты под VirtualPC, для чего наняли мелкий немецкий стартап. Профит был в том, что их гипервизор мог запускать OS/2 без технологии VTX, что оказалось очень важным для немецкого рынка

- Что интересного было в дизайне. Использование того факта, что у процессоров интела есть более двух колец защиты(пользовательский код и код операционной системы). У интеловских камней их 4(для ядерного кода используется нулевое кольцо, для пользовательского - третье). Зачем первое? В основном для того, чтобы драйвера устройств(которые делают третьи стороны и которые лезут в ядро ОС) имели чуть меньший уровень привилегий чем код ОС и больший, чем код пользователя. А зачем четвертое кольцо? Потому что на уровень привилегий в регистре отводится два бита, четвертое появилось просто как лишнее. Это позволяет отделить уровень привилегий гостевой системы, ее юзерспейса, и хостовой системы друг от друга

- Какие проблемы у гипервизоров?
    - Производительность. Есть эмулятор bochs - наивная реализация всей мыслимой периферии, которая очень медленно работает. Решение - контроль управления памятью, вводом-выводом, сетевой картой(взаимодействие с контрольными регистрами процессора), трансляции адресов.
    - Обработка прерываний(внешних - от оборудования, внутренних - системных вызовов и тд)
    - Канал информации, потому что хочется пользоваться буфером обмена например
    - Ввод-вывод, потому что хочется использовать хостовый диск из гостевой системы

- Дизайнерские решения, продолжение:
    - Максимальный процент непосредственного исполнения на процессоре
    - Использование аппартного менеджера памяти. Программный MMU убивает производительность
    - Правильная диспетчеризация прерываний
    - Большая часть гипервизора помещается в ядро хостовой ОС(спорное с точки зрения безопасности, но все же)
    - Деление модели устройств на две части - исполняемую в контексте ядра и в контексте гипервизора(частые операции помещаем в места, которые исполняются быстро)

- Кому диспетчеризовать события(про ввод-вывод)
    - В памяти строится нечто типа дерева отрезков(какому устройству принадлжежит адрес, в котором случился фолт)
    - Используются паравиртуализированые драйвера, чтобы ускорить процесс ввода-вывода
    - Кроме того, во многих гипервизорах реализован "проброс" устройств(как правило PCI - пробрасываем диапазоны физической памяти и USB - ???). В чем может быть сложность? В том, что есть технология DMA(прямой доступ к памяти) и устройство ничего не знает про гостевые системы. Интел и АМД сделали технологию VT-d - аппаратная поддержка DMA(краткое описание есть даже в Википедии)
