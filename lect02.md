Виртуальные машины. Лекция 2

Java Virtual Machine:
  * Исполняет байткод(байткод потому что опкод у инструкций помещается в один байт). Байткод неплохо переводится обратно в исходный код на джаве(в отличии от языка С, потому что при трансляции нет оптимизаций - ей занимается JIT)
  * Как исполняет? Из чего состоит:
    * Все начинается с загрузчика классов. У байткода есть сериализованный формат(.class, в андроиде в .apk классы лежат в .dex). Берет сериализованные данные класса, анализирует на соответствие инвариантам, заложенным в спецификации. Зачем? - чтобы при линковке байткода не прилинковать фигню. Какие инварианты - ну например совместимость типов, контракты методов, корректность вычислений на стеке
    * Какая-то система исполнения байткода. Какая? Интерпретация, JIT-компиляция, исполнить на процессоре, которые умеют в байткод(на рынке еще живы ARM-процессоры, которые умеют в некоторое подмножество байткода - Jazelle). Нередко частью системы исполнения является динамический профилировщик, собирающий статистику и анализирующий её
    * Система управления памятью(сборщик мусора)
    * Ahead-of-time оптимизаторы(опциональная штука). Предзагрузка часто используемых классов и так далее.
  * Очень хорошо специфицирована, на многие вопросы есть ответ в спецификации. Формат файлов(.class) так же описан в спецификации. Там же описан набор инструкций и специфицирована ширина данных, с которыми работает JVM
  <!-- Байка Иготти про strictfp и реализацию операций с плавающей точкой на процах Intel -->
  * С точки зрения инструкций - абстрактная стековая машина, похожая на программируемый микрокалькулятор( =) ). Есть таблица локалов, по которой можно их адресовать. Размер - меньше ста операций.
  * Специфицирована инициализация объектов, классов(класс-инициализатор), как происходит поток нормального исполнения, сценарий нетривиального развития событий(исключения)
  * Некоторые части не совсем описаны в стандарте, но являются необходимой частью экосистемы языка - ввод и вывод, сеть, вызов нативного кода, графический интерфейс(сначала awt, потом уже появился swing)
  <!-- Байка Иготти про количество IDE для языка -->
  * Формат хорош для инструментации языка

Зачем в JVM столько компонентов?
  * Борьба с болью, после написания кода на С
  * Переносимость, обратная совместимость
  * Одним словом - большие программы проще писать на Java нежели на C. Индустриальное программирование - это разработка экосистемы и жизнь в ней. Инструментация JVM позволяет упростить себе жизнь

Система управления памятью в JVM
  * Стандарт, как и всегда, описывает контракты для системы управления памятью
  * Какие есть важные контракты:
    * Память всегда выделяется под конкретный объект(нет void*)
    * Память всегда инициализируется(Для всех типов есть значение по умолчанию, забитое нулями). Потом уже вызывается конструктор
    * Память освобождается или не освобождается при доступности объекта(то есть можно написать JVM и без сборщика мусора). Понятно, что такая реализация особо никому не нужна, поэтому все таки используют GC
    * Нет псевдонимов, то есть один и тот же блок памяти используется под один объект
    * Если память кончается, то кидается OutOfMemoryError(нет UB, как в С)
    * У каждого объекта, перекрывающего finalize() он будет вызван в момент рекламации объекта

У объектов есть типовая метаинформация, в отличии от примитивных типов, поэтому их можно хранить в контейнерах(можно спросить на этапе комиляции), поэтому в Java такие унылые дженерики.

После выделения памяти происходит инициализация объекта, потом он его используется, и переходит в состояние неиспользуемого. Как понять, используется ли объект или нет?
  * Счетчик ссылок(циклические ссылки и избыточная информация)
  * Граф объектов(долго и требуется стабильность графа объектов)
