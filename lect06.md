Вирутальные машины. Лекция 6

* Динамическая трансляция
    * Серверный транслятор С2.
        - Цель дизайна - создать транслятор, генерирующий более оптимальный код ценой больших усилий на этапе компиляции. Ожидаемый сценарий - долгоиграющие приложения, у которых ожидание по производительности растянуты по времени. Работает в несколько проходов, анализируя граф несколько раз. Как и в остальном хотспоте, анализирует common path. Некоторые общечеловеческие эвристики - обработчики исключений и проверки на нуллпоинтер не так часто вызываются, как, например, вызов каких-нибудь коротких функций, которые можно в таком случае встроить. Кроме того, он собирает статистику, как мы исполянемся. И если он видит, что мы исполянемся не так, как ожидаелось, то он откатывается к интерпретатору байткода.  

        - Интересна так же форма IR - явная зависимость по данным между SSA-подобными узлами(то есть он явно пытается контроллировать зависимости по данным на этапе парсинга программы). Data-flow-analysis - это хороший ключ к вычислению сайд-эффектов(мы понимаем, какие вычисления зависят от каких). Но есть и проблемы - например, такую структуру сложнее строить, она более громоздкая. На более низком уровне IR у С2 представляет собой некоторое машиннозависимое представление. Есть файл описания архитектуры, где описаны операции и их веса. Алгоритм смотрит, как ему выразить желаемую семантику с помощью low-level-IR так чтобы суммарный вес был минимален, а далее идет регистровая аллокация. Есть peephole-optimization. О регистровой аллокации можно думать, как о раскраске графа времени жизни объектов в n цветов, где n - это количество регистров(алгоритм Чайтена или как-то так, кубический относительно количества узлов). Некоторые классические оптимизации в С2:
            - Есть global-value-numbering. Каждому виртуальному регистру значение присвивается один раз, следовательно если мы видим два присваивания с одинаковой правой частью, то можно заменить ее на левую часть того присваивания, которого мы увидили раньше
            - Еще классические оптимизации - constant-folding, constant-propagation. Забавно, что в джаве нет ключевого слова const(есть final), но final вовсе не означает, что значение является константой.
            - Loop-unrolling - разворачивание циклов, когда тело цикла выписывают несколько раз подряд(меньше проверок на границе цикла). Понятно, что больше, чем размер кэша инструкций разворачивать не надо
            - Вынос инваринтов цикла. Если вычисление не зависит от вычисления в цикле и не дает сайд-эффектов, то его можно вынести.
            - Соединение смежного доступа. Чтение полей в большие значения и разнос и на уровне регистров(довольно спорная оптимизация, потому что есть кэш процессора)
            - Устранение проверок на нулл. Можно вообще не проверять на нулл, кроме нескольких маргинальных случаев. Хотспот осуществляет инъекцию прерывания при разыменовании поля, которое лежит близко к нулю(как мы помним из курса ОС в этом случае процессу летит SIGSEGV)
            - Удаление мертвого кода
            - Code motion. Что-типа инлайнинга на стероидах
            - Векторизация. Кстати довольно сложная оптимизация. Нужно совершить большое число телодвижений, чтобы независимо расщепить циклы и вызвать для них векторные инструкции
            - Инлайнинг
            - Range-check-elimination
            - Escape-analysis. Возможность доказать про объект, что ссылки на него не убегают из некоторого контекста
            - Деполиморфизация(вроде что-то обсуждалось на прошлых лекциях)
            - Fast-path-linearization - на основе рантаймового знания о том, кто кого вызывает создаем линейный участок кода с такими же сайд-эффектами
            - Branch prediction(тоже обсуждалась)
            - Class-hierarchy analysis
            - Autoboxing removal
            - Lock elision

        - Еще есть куча некомпиляторных оптимизаций, но их мы обсудим в следующих лекциях. Сейчас мы их просто упомянем:
            - Biased locks
            - ...

        - Многоуровневая компиляция. Мысль в том, что почему бы не использовать лучшее из двух трансляторов. То есть для не очень важного кода использовать клиентский транслятор, для важного - серверный. Есть еще нулевой уровень - использование интерпретатора байткода
